{"version":3,"sources":["images/white.svg","images/black.svg","Horse/Horse.js","components/Field/Field.js","AI/AI.js","AI/AI_JK.js","components/Board/Board.js","Helper.js","components/App/App.js","index.js"],"names":["module","exports","Horse","i","j","mode","HORSE_W","this","validateMode","val","HORSE_B","_i","_j","size","horses","k","wj","push","bi","bj","position","filter","possibility","from","to","Field","isCenter","pawn","classList","select","className","onClick","src","white","alt","black","AI","field","pawnPositions","value","find","includes","fieldsWithValues","minimax","Number","NEGATIVE_INFINITY","POSITIVE_INFINITY","depth","nodeIndex","maximizingPlayer","values","alpha","beta","best","Math","max","min","_pawnGroups","0","1","2","3","4","_pawnGroupValue","self","whitePawns","blackPawns","whitePawnsScore","forEach","_getPositionScore","blackPawnsScore","group","Object","entries","key","pos","yourPawnPositions","possibleMoves","y","x","yourPawns","enemyPawns","allPawnMoves","_getPossibleMoves","move","yourPawnsCopy","enemyPawnsCopy","splice","enemyPawnId","findIndex","concat","moves","alfa","pawnMove","moveFrom","score","moveScore","_minMax","sort","a","b","topScore","bestMoves","console","log","floor","random","length","_calculateScore","currentMovePawns","currentMovePawnsCopy","currentMove","unshift","scores","every","React","memo","props","undefined","useState","currentPlayer","setCurrentPlayer","selectedPawn","setSelectedPawn","winner","setWinner","getInitialHorsesPositions","setPawnPositions","selectField","performBeating","makeMove","previousPosition","validateMove","newPositions","map","ceil","pawnToBeat","board","dimension","Fields","l","m","getClassList","row","column","myArray","chunk_size","index","arrayLength","tempArray","myChunk","slice","chunkArray","createBoard","columns","aiMove","setAiMove","useEffect","ai","AI_JK","possibilities","getMOVES","next","calculateValue","flat","makeDecision","getBestMove","AITurn","window","location","reload","prev","idx","App","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.1262029d.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/white.83c6f684.svg\";","module.exports = __webpack_public_path__ + \"static/media/black.3e68d800.svg\";","export default class Horse {\n  constructor(i = 0, j = 0, mode = Horse.HORSE_W()) {\n    this.i = i;\n    this.j = j;\n    this.mode = this.validateMode(mode);\n  }\n\n  static get HORSE_W() {\n    return 0;\n  }\n\n  static get HORSE_B() {\n    return 1;\n  }\n\n  static getInitialHorsesPositions(size) {\n    let horses = [];\n    for (let k = 0; k < size; k++) {\n      let wi = 0;\n      let wj = k;\n      horses.push(new Horse(wi, wj, Horse.HORSE_W));\n    }\n    for (let k = size; k > 0; k--) {\n      let bi = size - 1;\n      let bj = k - 1;\n      horses.push(new Horse(bi, bj, Horse.HORSE_B));\n    }\n\n    return horses;\n  }\n\n  validateMode(val) {\n    if (val !== Horse.HORSE_W && val !== Horse.HORSE_B) {\n      return Horse.HORSE_W; // Default to white\n    }\n    return val;\n  }\n\n  static getMOVES(position) {\n    const moves = [\n      { i: position.i - 2, j: position.j - 1 },\n      { i: position.i - 2, j: position.j + 1 },\n      { i: position.i - 1, j: position.j - 2 },\n      { i: position.i - 1, j: position.j + 2 },\n      { i: position.i + 1, j: position.j - 2 },\n      { i: position.i + 1, j: position.j + 2 },\n      { i: position.i + 2, j: position.j - 1 },\n      { i: position.i + 2, j: position.j + 1 }\n    ];\n    return moves.filter(\n      possibility =>\n        !(\n          possibility.i > 9 - 1 ||\n          possibility.j > 9 - 1 ||\n          possibility.i < 0 ||\n          possibility.j < 0\n        )\n    );\n  }\n\n  static validateMove(from, to) {\n    if (from.i === to.i - 2 && from.j === to.j - 1) return true;\n    if (from.i === to.i - 2 && from.j === to.j + 1) return true;\n    if (from.i === to.i - 1 && from.j === to.j - 2) return true;\n    if (from.i === to.i - 1 && from.j === to.j + 2) return true;\n    if (from.i === to.i + 1 && from.j === to.j - 2) return true;\n    if (from.i === to.i + 1 && from.j === to.j + 2) return true;\n    if (from.i === to.i + 2 && from.j === to.j - 1) return true;\n    if (from.i === to.i + 2 && from.j === to.j + 1) return true;\n    return false;\n  }\n\n  getClassList() {\n    return `horse ${this.mode === Horse.HORSE_W ? \"white\" : \"black\"}`;\n  }\n\n  getPosition() {\n    return { i: this.i, j: this.j };\n  }\n\n  setPosition(_i, _j) {\n    if (!_i || !_j) {\n      throw \"Invalid position!\";\n    }\n    if (_i <= 0 || _j <= 0) {\n      throw \"Invalid position!\";\n    }\n    this.i = _i;\n    this.j = _j;\n  }\n}\n","import React from \"react\";\nimport Horse from \"../../Horse/Horse\";\nimport \"./Field.scss\";\nimport white from \"../../images/white.svg\";\nimport black from \"../../images/black.svg\";\n\nexport default function Field({ position, isCenter, pawn, classList, select }) {\n  return (\n    <div\n      className={`Field ${isCenter ? \"center\" : \"\"}`}\n      onClick={() => select(position, pawn)}\n    >\n      {pawn && (\n        <div className={classList}>\n          {pawn.mode === Horse.HORSE_W && (\n            <img src={white} alt=\"white-horse\" className=\"pawn\" />\n          )}\n          {pawn.mode === Horse.HORSE_B && (\n            <img src={black} alt=\"black-horse\" className=\"pawn\" />\n          )}\n        </div>\n      )}\n    </div>\n  );\n}\n","export default class AI {\n  static calculateValue(field, pawnPositions) {\n    let value = 0;\n    // SET VALUES TO ZERO FOR FIELDS WHERE ALREADY IS A BLACK PAWN\n    if (\n      pawnPositions.find(\n        position =>\n          position.i === field.i &&\n          position.j === field.j &&\n          position.mode === 1\n      )\n    ) {\n      return 0;\n    }\n    //IF IM ON CENTER THEN MOST IMPORTANT TO LEAVE\n    if (\n      pawnPositions.find(\n        position => position.i === 4 && position.j === 4 && position.mode === 1\n      ) &&\n      (((field.i === 2 || field.i === 6) && field.j === 3) ||\n        ((field.i === 2 || field.i === 6) && field.j === 5))\n    ) {\n      return 200;\n    }\n    if (field.i === 4 && field.j === 4) {\n      //VALUE FOR CENTER\n      value += 50;\n      //IF THERE'S OPPONENT ON CENTER\n      if (\n        pawnPositions.find(\n          position =>\n            position.i === 4 && position.j === 4 && position.mode === 0\n        )\n      ) {\n        value += 100;\n      }\n      return value;\n    }\n\n    //VALUE FOR FIELD FROM WHICH NEXT MOVE COULD BE MADE TO CENTER\n    if (\n      ((field.i === 2 || field.i === 6) && field.j === 3) ||\n      ((field.i === 2 || field.i === 6) && field.j === 5)\n    ) {\n      value += 25;\n      //IF THERE'S OPPONENT THERE\n      if (\n        pawnPositions.find(\n          position =>\n            (((field.i === 2 || field.i === 6) && field.j === 3) ||\n              ((field.i === 2 || field.i === 6) && field.j === 5)) &&\n            position.mode === 0\n        )\n      ) {\n        value += 12;\n      }\n      return value;\n    }\n    if ([2, 4, 6].includes(field.j) && [0, 4, 8].includes(field.i)) {\n      value += 12;\n      if (\n        pawnPositions.find(\n          position =>\n            [2, 4, 6].includes(position.j) &&\n            [0, 4, 8].includes(position.i) &&\n            position.mode === 0\n        )\n      ) {\n        value += 6;\n      }\n      return value;\n    }\n    if ([1, 7].includes(field.j) && [2, 6].includes(field.i)) {\n      value += 6;\n      if (\n        pawnPositions.find(\n          position =>\n            [0, 8].includes(position.j) &&\n            [0, 8].includes(position.i) &&\n            position.mode === 0\n        )\n      ) {\n        value += 3;\n      }\n      return value;\n    }\n    if ([0, 8].includes(field.j) && [0, 8].includes(field.i)) {\n      value += 3;\n      if (\n        pawnPositions.find(\n          position =>\n            [0, 8].includes(position.j) &&\n            [0, 8].includes(position.i) &&\n            position.mode === 0\n        )\n      ) {\n        value += 1;\n      }\n      return value;\n    }\n\n    return 2;\n  }\n  //TODO: Model for certain moves depending how close they are to center\n  //TODO: Model for additional points depended on beating pawn postision\n  //TODO: IF Center then most important is to leave the field\n\n  static makeDecision(fieldsWithValues) {\n    const decision = AI.minimax(\n      0,\n      0,\n      true,\n      fieldsWithValues,\n      { value: Number.NEGATIVE_INFINITY },\n      { value: Number.POSITIVE_INFINITY }\n    );\n    return decision;\n  }\n  // values {from, to:[{},{}]}\n  static minimax(depth, nodeIndex, maximizingPlayer, values, alpha, beta) {\n    if (depth === 2) return values[nodeIndex];\n\n    if (maximizingPlayer) {\n      let best = { value: Number.NEGATIVE_INFINITY };\n      for (let i = 0; i < 2; i++) {\n        let val = AI.minimax(\n          depth + 1,\n          nodeIndex * 2 + i,\n          false,\n          values,\n          alpha,\n          beta\n        );\n        best = Math.max(best.value, val.value) === best.value ? best : val;\n        alpha = Math.max(alpha.value, best.value) === best.value ? best : alpha;\n        if (beta.value <= alpha.value) break;\n      }\n      return best;\n    } else {\n      let best = { value: Number.POSITIVE_INFINITY };\n      for (let i = 0; i < 2; i++) {\n        let val = AI.minimax(\n          depth + 1,\n          nodeIndex * 2 + i,\n          true,\n          values,\n          alpha,\n          beta\n        );\n        best = Math.min(best.value, val.value) === best.value ? best : val;\n        beta = Math.min(beta.value, best.value) === best.value ? best : beta;\n        if (beta.value <= alpha.value) break;\n      }\n      return best;\n    }\n  }\n}\n","import Horse from \"../Horse/Horse\";\n\nexport default class AI {    \n    _pawnGroups = {\n        0: [\n            {i: 0, j : 0},\n            {i: 0, j : 8},\n            {i: 2, j : 2},\n            {i: 2, j : 6},\n            {i: 6, j : 2},\n            {i: 6, j : 6},\n            {i: 8, j : 0},\n            {i: 8, j : 8},\n        ],\n        1: [\n            {i: 0, j : 1},\n            {i: 0, j : 3},\n            {i: 0, j : 5},\n            {i: 0, j : 7},\n            {i: 1, j : 0},\n            {i: 1, j : 2},\n            {i: 1, j : 4},\n            {i: 1, j : 6},\n            {i: 1, j : 8},\n            {i: 2, j : 1},\n            {i: 2, j : 7},\n            {i: 3, j : 0},\n            {i: 3, j : 4},\n            {i: 3, j : 8},\n            {i: 4, j : 1},\n            {i: 4, j : 3},\n            {i: 4, j : 5},\n            {i: 4, j : 7},\n            {i: 5, j : 0},\n            {i: 5, j : 4},\n            {i: 5, j : 8},\n            {i: 6, j : 1},\n            {i: 6, j : 7},\n            {i: 8, j : 1},\n            {i: 8, j : 3},\n            {i: 8, j : 5},\n            {i: 8, j : 7},\n            {i: 7, j : 0},\n            {i: 7, j : 2},\n            {i: 7, j : 4},\n            {i: 7, j : 6},\n            {i: 7, j : 8}\n        ],\n        2: [\n            {i: 0, j : 2},\n            {i: 0, j : 4},\n            {i: 0, j : 6},\n            {i: 1, j : 1},\n            {i: 1, j : 3},\n            {i: 1, j : 5},\n            {i: 1, j : 7},\n            {i: 2, j : 0},\n            {i: 2, j : 4},\n            {i: 2, j : 8},\n            {i: 3, j : 1},\n            {i: 3, j : 3},\n            {i: 3, j : 5},\n            {i: 3, j : 7},\n            {i: 4, j : 0},\n            {i: 4, j : 2},\n            {i: 4, j : 6},\n            {i: 4, j : 8},\n            {i: 8, j : 2},\n            {i: 8, j : 4},\n            {i: 8, j : 6},\n            {i: 7, j : 1},\n            {i: 7, j : 3},\n            {i: 7, j : 5},\n            {i: 7, j : 7},\n            {i: 6, j : 0},\n            {i: 6, j : 4},\n            {i: 6, j : 8},\n            {i: 5, j : 1},\n            {i: 5, j : 3},\n            {i: 5, j : 5},\n            {i: 5, j : 7}\n        ],\n        3: [\n            {i: 2, j : 3},\n            {i: 2, j : 5},\n            {i: 3, j : 2},\n            {i: 3, j : 6},\n            {i: 5, j : 2},\n            {i: 5, j : 6},\n            {i: 6, j : 3},\n            {i: 6, j : 5}\n        ],\n        4: [\n            {i: 4, j: 4}\n        ]\n    };\n\n    _pawnGroupValue = {\n        0: 4,\n        1: 8,\n        2: 16,\n        3: 28,\n        4: 44\n    };\n\n    /**\n     * Method that return value for given state\n     * Black pawns are going to add value\n     * White pawns are going to substract value\n     */\n    _calculateScore(pawnPositions, mode = 1) {\n        var self = this;\n\n        const whitePawns = pawnPositions.filter(pawn => {\n            return pawn.mode === Horse.HORSE_W;\n        });\n\n        const blackPawns = pawnPositions.filter(pawn => {\n            return pawn.mode === Horse.HORSE_B;\n        });\n\n        let whitePawnsScore = 0;\n        whitePawns.forEach(pawn => {\n            whitePawnsScore += self._getPositionScore(pawn.i, pawn.j)\n        });\n\n        let blackPawnsScore = 0;\n        blackPawns.forEach(pawn => {\n            blackPawnsScore += self._getPositionScore(pawn.i, pawn.j)\n        });\n\n        return (mode === 1)? blackPawnsScore - whitePawnsScore: whitePawnsScore - blackPawnsScore;\n    }\n    \n    /**\n     * Method that returns score based on pawn position\n     * @param {int} i position i\n     * @param {int} j position j\n     * @returns {int} score\n     */\n    _getPositionScore(i, j) {\n        var group;\n\n        for(let [key, value] of Object.entries(this._pawnGroups)) {\n            if(value.find(pos => {\n                return pos.i === i && pos.j === j;\n            })) {\n                group = key;\n                break;\n            }\n        }\n\n       return this._pawnGroupValue[group];\n    }\n\n    /**\n     * Method that retuns all possible moves \n     * @param {int} i \n     * @param {int} j \n     * @returns {array[objects]} eg. [{i, j}, {i, j}]\n     */\n    _getPossibleMoves(i, j, yourPawnPositions) {\n        let possibleMoves = [];\n\n        for(let y = -2; y <= 2; y+=4) {\n            for(let x = -1; x <= 1; x+=2) {\n                let pos = {\n                    i: i + y,\n                    j: j + x\n                };\n\n                if(pos.i <= 8 && pos.i >= 0 && pos.j <= 8 && pos.j >= 0) {\n                    if(!yourPawnPositions.find(pawn => {\n                        return pawn.i === pos.i && pawn.j === pos.j\n                    })) {\n                        possibleMoves.push(pos);\n                    }\n                }\n            }\n        }\n\n        for(let x = -2; x <= 2; x+=4) {\n            for(let y = -1; y <= 1; y+=2) {\n                let pos = {\n                    i: i + y,\n                    j: j + x\n                };\n\n                if(pos.i <= 8 && pos.i >= 0 && pos.j <= 8 && pos.j >= 0) {\n                    if(!yourPawnPositions.find(pawn => {\n                        return pawn.i === pos.i && pawn.j === pos.j\n                    })) {\n                        possibleMoves.push(pos);\n                    }\n                }\n            }\n        }\n\n        return possibleMoves;\n    }\n\n    /**\n     * Method that returns best move possible calculated by min max\n     * @param {array[object]} pawnPositions \n     * @param {int} depth \n     * @returns {object} {i, j}\n     */\n    getBestMove(pawnPositions, depth) {\n        const yourPawns = pawnPositions.filter(pawn => pawn.mode === Horse.HORSE_B);\n        const enemyPawns = pawnPositions.filter(pawn => pawn.mode === Horse.HORSE_W);\n\n        let allPawnMoves = [];\n\n        yourPawns.forEach((pawn, i) => {\n            let allPossibleMoves = this._getPossibleMoves(pawn.i, pawn.j, yourPawns);\n\n            allPossibleMoves.forEach(move => {\n                let yourPawnsCopy = [...yourPawns];\n                let enemyPawnsCopy = [...enemyPawns];\n\n                yourPawnsCopy.splice(i, 1, new Horse(move.i, move.j, Horse.HORSE_B));\n            \n                let enemyPawnId = enemyPawnsCopy.findIndex(pawn => {\n                    return pawn.i === move.i && pawn.j === move.j;\n                });\n\n                if(enemyPawnId !== -1) {\n                    enemyPawnsCopy.splice(enemyPawnId, 1);\n                }\n\n                allPawnMoves.push({\n                    move: {\n                        from: {\n                            i: pawn.i,\n                            j: pawn.j\n                        },\n                        to: {\n                            i: move.i,\n                            j: move.j\n                        }\n                    },\n                    pawnPositions: yourPawnsCopy.concat(enemyPawnsCopy)\n                });\n            });\n        });\n\n        let moves = [];\n\n        let alfa = Number.NEGATIVE_INFINITY;\n        let beta = Number.POSITIVE_INFINITY;\n\n        allPawnMoves.forEach(pawnMove => {\n            const moveFrom = pawnMove.move.from;\n            if(moveFrom.i === 4 && moveFrom.j === 4) {\n                moves.push({ score: 9999, pawnMove});\n                alfa = 9999;\n            } else {\n                let moveScore = this._minMax(depth - 1, [...pawnMove.pawnPositions], Horse.HORSE_W, alfa, beta);\n                moves.push({score: moveScore, pawnMove});\n                alfa = (moveScore > alfa)? moveScore: alfa;\n            }\n        });\n\n        moves.sort((a, b) => { return b.score - a.score});\n        \n        let topScore = moves[0].score;\n        const bestMoves = moves.filter((move) => move.score === topScore);\n\n        console.log(topScore);\n\n        return bestMoves[Math.floor(Math.random() * bestMoves.length)];\n    }\n\n    /**\n     * \n     * @param {int} depth how many your moves ahead you want to predict, eg. if you set it to 0, it will only count current state, if you set it to 1, it will predict your move based on the move after enemy move\n     * @param {array[object]} pawnPositions all pawns\n     * @param {int} mode 0 - your pawn are white, 1 - your pawns are black\n     * @returns {float} score\n     */\n    _minMax(depth, pawnPositions, mode, alfa, beta) {\n        var self = this;\n\n        if(depth === 0) {   \n            return self._calculateScore(pawnPositions);\n        } else {\n            const currentMovePawns = pawnPositions.filter(pawn => pawn.mode === mode);\n            const enemyPawns = pawnPositions.filter(pawn => pawn.mode !== mode);\n\n            let allPawnMoves = [];\n\n            currentMovePawns.forEach((pawn, i) => {\n                let allPossibleMoves = this._getPossibleMoves(pawn.i, pawn.j, currentMovePawns);\n    \n                allPossibleMoves.forEach(move => {\n                    let currentMovePawnsCopy = [...currentMovePawns];\n                    currentMovePawnsCopy.splice(i, 1, new Horse(move.i, move.j, (mode === 0)? Horse.HORSE_W: Horse.HORSE_B));\n                    let enemyPawnsCopy = [...enemyPawns];\n\n                    let enemyPawnId = enemyPawnsCopy.findIndex(pawn => {\n                        return pawn.i === move.i && pawn.j === move.j;\n                    });\n    \n                    if(enemyPawnId !== -1) {\n                        enemyPawnsCopy.splice(enemyPawnId, 1);\n                    }\n\n                    var currentMove = {\n                        move: {\n                            from: {\n                                i: pawn.i,\n                                j: pawn.j\n                            },\n                            to: {\n                                i: move.i,\n                                j: move.j\n                            }\n                        },\n                        pawnPositions: currentMovePawnsCopy.concat(enemyPawnsCopy)\n                    };\n\n                    if(enemyPawnId !== -1) {\n                        allPawnMoves.unshift(currentMove);\n                    } else {\n                        allPawnMoves.push(currentMove);\n                    }\n                });\n            });\n\n            let scores = [];\n        \n            allPawnMoves.every(pawnMove => {\n                const moveFrom = pawnMove.move.from;\n\n                if(moveFrom.i === 4 && moveFrom.j === 4) {\n                    if(mode === 1) {\n                        beta = -9999;\n                    } else {\n                        alfa = 9999;\n                    }\n\n                    scores.push((mode === 0)? -9999: 9999);\n                } else {\n                    let moveScore = this._minMax(depth - 1, [...pawnMove.pawnPositions], (mode === 0)? 1: 0, alfa, beta);\n\n                    if(mode === 1) {\n                        alfa = (moveScore > alfa)? moveScore: alfa;\n                    } else {\n                        beta = (moveScore < beta)? moveScore: beta;\n                    }\n                    \n                    scores.push(moveScore);\n                }\n\n                if(alfa >= beta) {\n                    return;\n                }\n            });\n\n            if(mode === 0) {\n                scores.sort((a, b) => { return a - b });\n            } else {\n                scores.sort((a, b) => { return b - a });\n            }\n\n            return scores[0];\n        }\n    }\n}","import React, { useState, useEffect } from \"react\";\nimport Field from \"../Field/Field\";\nimport { chunkArray } from \"../../Helper\";\nimport Horse from \"../../Horse/Horse\";\nimport AI from \"../../AI/AI\";\nimport * as _ from \"lodash\";\nimport \"./Board.scss\";\nimport AI_JK from \"../../AI/AI_JK\";\n\nconst CUR_PLAYER_W = 0;\nconst CUR_PLAYER_B = 1;\n\nfunction Board(props) {\n  //VALIDATE BOARD SIZE\n  let size;\n  // Board size must be greater than 5 and odd-sized\n  if (props.size === undefined || props.size < 5 || props.size % 2 !== 1) {\n    console.log(\"Invalid board size!!\");\n    size = 9;\n  } else {\n    size = props.size;\n  }\n\n  // STATUS VARIABLES\n  // White by default as white always starts\n  const [currentPlayer, setCurrentPlayer] = useState(CUR_PLAYER_W);\n  // Pawn from which player wants to make a move\n  const [selectedPawn, setSelectedPawn] = useState({\n    i: null,\n    j: null,\n    mode: null\n  });\n  // Determines if we have a winner\n  const [winner, setWinner] = useState(null);\n\n  // Horse positions\n  const [pawnPositions, setPawnPositions] = useState(\n    Horse.getInitialHorsesPositions(size)\n  );\n\n  //BOARD CREATION\n  let dimension = size * size;\n\n  const selectField = (position, pawn) => {\n    if (winner) return;\n    if (pawn) {\n      if (currentPlayer === pawn.mode) {\n        setSelectedPawn(pawn);\n      } else {\n        performBeating(position);\n      }\n    } else {\n      makeMove(position);\n    }\n  };\n\n  const makeMove = position => {\n    const previousPosition = {\n      i: selectedPawn.i,\n      j: selectedPawn.j,\n      mode: selectedPawn.mode\n    };\n    if (\n      currentPlayer === selectedPawn.mode &&\n      Horse.validateMove(previousPosition, position)\n    ) {\n      const newPositions = pawnPositions.map(pawn =>\n        pawn.i === selectedPawn.i && pawn.j === selectedPawn.j\n          ? new Horse(position.i, position.j, currentPlayer)\n          : pawn\n      );\n      setPawnPositions(newPositions);\n      setSelectedPawn(new Horse(null, null, null));\n      //CHANGE TURN\n      if (currentPlayer === CUR_PLAYER_W) {\n        setCurrentPlayer(CUR_PLAYER_B);\n      } else {\n        setCurrentPlayer(CUR_PLAYER_W);\n      }\n      //CHECK IF WHITE WON\n      if (\n        !newPositions.find(pawn => pawn.mode === 1) ||\n        (previousPosition.i === Math.ceil((size - 1) / 2) &&\n          previousPosition.j === Math.ceil((size - 1) / 2) &&\n          previousPosition.mode === 0 &&\n          !newPositions.find(\n            pawn =>\n              pawn.mode === 0 &&\n              pawn.i === previousPosition.i &&\n              pawn.j === previousPosition.j\n          ))\n      ) {\n        setWinner(0);\n      }\n      //CHECK IF BLACK WON\n      if (\n        !newPositions.find(pawn => pawn.mode === 0) ||\n        (previousPosition.i === Math.ceil((size - 1) / 2) &&\n          previousPosition.j === Math.ceil((size - 1) / 2) &&\n          previousPosition.mode === 1 &&\n          !newPositions.find(\n            pawn =>\n              pawn.mode === 1 &&\n              pawn.i === previousPosition.i &&\n              pawn.j === previousPosition.j\n          ))\n      ) {\n        setWinner(1);\n      }\n    } else if (selectedPawn) {\n      console.log(\"Not your turn or unproper move Sir\");\n    }\n  };\n\n  const performBeating = position => {\n    if (\n      !Horse.validateMove({ i: selectedPawn.i, j: selectedPawn.j }, position)\n    ) {\n      return;\n    }\n    const pawnToBeat = pawnPositions.findIndex(\n      pawn => pawn.i === position.i && pawn.j === position.j\n    );\n    pawnPositions.splice(pawnToBeat, 1);\n    setPawnPositions([...pawnPositions]);\n    makeMove(position);\n  };\n\n  const createBoard = dimension => {\n    let i, j;\n    for (let k = 0; k < dimension; k++) {\n      // Calculate Indexes\n      i = Math.ceil((k + 1) / size);\n      j = (k + 1) % size;\n      if (j === 0) j = size;\n    }\n    let Fields = [];\n    for (let l = 0; l < i; l++) {\n      for (let m = 0; m < j; m++) {\n        let classList;\n        let position = { i: l, j: m };\n        let pawn = pawnPositions.find(pawn => pawn.i === l && pawn.j === m);\n        if (pawn) {\n          classList = pawn.getClassList();\n        }\n        if (position.i === selectedPawn.i && position.j === selectedPawn.j) {\n          classList += \" selected\";\n        }\n        if (\n          l === Math.ceil((size - 1) / 2) &&\n          m === Math.ceil((size - 1) / 2)\n        ) {\n          Fields.push(\n            <Field\n              row={l}\n              column={m}\n              key={`${position.i}:${position.j}`}\n              position={position}\n              isCenter={true}\n              pawn={pawn}\n              classList={classList}\n              select={selectField}\n            />\n          );\n        } else {\n          Fields.push(\n            <Field\n              row={l}\n              column={m}\n              key={`${position.i}:${position.j}`}\n              position={position}\n              isCenter={false}\n              pawn={pawn}\n              classList={classList}\n              select={selectField}\n            />\n          );\n        }\n      }\n    }\n\n    return chunkArray(Fields, size);\n  };\n\n  let board = createBoard(dimension).map((columns, index) => (\n    <div className=\"row\" key={`column${index}`}>\n      {columns}\n    </div>\n  ));\n\n  const AITurn = () => {\n    var ai = new AI_JK();\n\n    //FOR EACH BLACK PAWN GET POSSIBLE FIELDS (Horse.getMOVES(pawnPosition)) THAT PAWN COULD BE MOVED TO [ARRAY OF {i,j}]\n    const possibilities = pawnPositions\n      .filter(pawn => pawn.mode === CUR_PLAYER_B)\n      .map(pawn => {\n        return {\n          to: Horse.getMOVES({ i: pawn.i, j: pawn.j }),\n          from: { i: pawn.i, j: pawn.j }\n        };\n      });\n\n    const possibilitiesOfPossibilities = possibilities.map(possibility => {\n      return {\n        ...possibility,\n        to: {\n          ...possibility.to,\n          next: possibility.to.map(to => Horse.getMOVES({ i: to.i, j: to.j }))\n        }\n      };\n    });\n\n    //CALCULATE VALUE FOR EVERY POSSIBLE FIELD (AI.calculateValue)\n    const fieldsWithValues = possibilities\n      .map(possibility =>\n        possibility.to.map(field => {\n          return {\n            ...field,\n            from: possibility.from,\n            value: AI.calculateValue(field, pawnPositions)\n          };\n        })\n      )\n      .flat(1);\n    //MAKE ALPHA-BETA MINMAX DECISION (AI.makeDecision)\n    const decision = AI.makeDecision(fieldsWithValues);\n    const jkDecision = ai.getBestMove(pawnPositions, 4);\n    const move = jkDecision.pawnMove.move;\n    \n    setSelectedPawn(new Horse(move.from.i, move.from.j, 1));\n    return { i: move.to.i, j: move.to.j };\n  };\n\n  const [aiMove, setAiMove] = useState(null);\n  useEffect(() => {\n    if (currentPlayer === CUR_PLAYER_B) {\n      const move = AITurn();\n      setAiMove(move);\n    }\n  }, [currentPlayer]);\n\n  useEffect(() => {\n    if (\n      currentPlayer === CUR_PLAYER_B &&\n      (selectedPawn.i || selectedPawn.i === 0) &&\n      aiMove\n    ) {\n      if (\n        pawnPositions.find(\n          pawn =>\n            pawn.i === aiMove.i &&\n            pawn.j === aiMove.j &&\n            pawn.mode === CUR_PLAYER_W\n        )\n      ) {\n        performBeating(aiMove);\n      } else {\n        makeMove(aiMove);\n      }\n    }\n  }, [selectedPawn, aiMove]);\n  //RENDERER\n  return (\n    <div className=\"Board\">\n      {board}\n      {winner === 0 && <h1>Player WHITE won!</h1>}\n      {winner === 1 && <h1>Player BLACK won!</h1>}\n      {/* js bullshit below (0 evaluates to false so need to check for exact val) */}\n      {(winner === 0 || winner === 1) && (\n        <button onClick={() => window.location.reload()}>Reset</button>\n      )}\n    </div>\n  );\n}\n\nexport default React.memo(Board, (prev, next) => {\n  if (\n    prev.currentPlayer !== next.currentPlayer ||\n    prev.selectedPawn !== next.selectedPawn\n  )\n    return true;\n  prev.pawnPositions.forEach((position, idx) => {\n    if (\n      !(\n        position.i === next.pawnPositions[idx].i &&\n        position.i === next.pawnPositions[idx].j &&\n        position.mode === next.pawnPositions[idx].mode\n      )\n    ) {\n      return false;\n    }\n  });\n  return true;\n});\n","export function chunkArray(myArray, chunk_size){\n    var index = 0;\n    var arrayLength = myArray.length;\n    var tempArray = [];\n    \n    for (index = 0; index < arrayLength; index += chunk_size) {\n        let myChunk = myArray.slice(index, index+chunk_size);\n        // Do something if you want with the group\n        tempArray.push(myChunk);\n    }\n\n    return tempArray;\n}","import React from 'react';\nimport './App.scss';\nimport Board from '../Board/Board';\n\nfunction App() {\n\n  return (\n    <div className=\"App\">\n      <Board size={9}/>\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.scss';\nimport App from './components/App/App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}